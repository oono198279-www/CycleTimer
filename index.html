<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
<title>CycleTimer-ラップでCT予測</title>
<!-- PWA / アイコン -->
<link rel="manifest" href="./manifest.webmanifest?v=4">
<link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png?v=4">
<link rel="apple-touch-icon" sizes="180x180" href="./icons/icon-180.png?v=4">
<meta name="theme-color" content="#0b0f12">

<style>
  :root{
    --bg:#0b0f12; --card:#11161a; --fg:#e5e7eb; --muted:#9ca3af; --border:#1f2937; --accent:#22c55e;
    --radius:14px; --pad:14px; --gap:12px; --mono: ui-monospace,SFMono-Regular,Menlo,Consolas,"Roboto Mono",monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%; -webkit-text-size-adjust:100%;}
  body{margin:0; background:var(--bg); color:var(--fg); font-family:-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial}
  .wrap{max-width:880px; margin:0 auto; padding:18px}
  header{position:sticky; top:0; background:linear-gradient(180deg, rgba(11,15,18,.98), rgba(11,15,18,.8) 60%, transparent); backdrop-filter: blur(6px); z-index:5}
  h1{margin:8px 0 14px; font-size:20px; letter-spacing:.02em}
  .grid{display:grid; grid-template-columns: 1fr; gap:var(--gap)}
  @media(min-width:820px){ .grid{ grid-template-columns: 1.1fr .9fr } }

  .card{background:var(--card); border:1px solid var(--border); border-radius:var(--radius); padding:var(--pad)}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .nowrap{flex-wrap:nowrap !important}
  .checkbox-line{display:flex; align-items:center; gap:8px; white-space:nowrap}
  .grow{flex:1}
  .muted{color:var(--muted)}
  .big{font-size:clamp(36px, 11vw, 64px); font-family:var(--mono); letter-spacing:.03em}
  .time{font-variant-numeric:tabular-nums}

  /* ★ KPIは基本2列。幅が足りない時だけ自動で1列へ */
  .kpis{display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:10px; margin-top:10px}
  .kpi{background:#0d1317; border:1px solid var(--border); border-radius:12px; padding:10px}
  .kpi .label{color:var(--muted); font-size:12px}
  .kpi .val{font-family:var(--mono); font-size:18px; margin-top:4px}

  button{appearance:none; border:1px solid var(--border); background:#0e1418; color:#e5e7eb; padding:12px 10px; border-radius:12px; cursor:pointer; font-weight:600; font-size:16px}
  button:active{transform:translateY(1px)}
  .primary{background:var(--accent); color:#052b18; border-color:#0e3f28}
  .warn{background:#ef4444; border-color:#7f1d1d; color:#330707}
  .ghost{background:#0e1418}
  .btn-row{display:flex; gap:10px; margin-top:10px}
  .btn-row button{flex:1; text-align:center}

  /* iPhone入力時ズーム対策＆可変幅で1行キープ */
  input[type="number"]{
    width:clamp(100px, 30vw, 140px);
    background:#0e1418; color:var(--fg); border:1px solid var(--border);
    padding:10px 12px; border-radius:10px; font-family:var(--mono); font-size:16px;
  }
  input[type="checkbox"]{transform:scale(1.2)}

  table{width:100%; border-collapse:collapse; font-variant-numeric:tabular-nums; font-family:var(--mono)}
  th,td{padding:8px 10px; border-bottom:1px solid var(--border); text-align:right; white-space:nowrap}
  th:first-child, td:first-child{text-align:left}

  /* 外れ値の見た目（平均計算からは除外・行は半透明で残す） */
  .excluded { opacity:.45; }
  .del{border:1px solid var(--border); background:#0d1317; color:var(--fg); width:28px; height:28px; border-radius:8px; font-size:18px; line-height:24px; cursor:pointer}
  .del:active{transform:scale(0.98)}

  /* ===== 超小幅端末向けフォールバック（横スクロール防止） ===== */
  @media (max-width: 390px) {
    .nowrap { flex-wrap: wrap !important; }
    input[type="number"] { width:100%; max-width:260px; }
    .checkbox-line { white-space:normal; gap:6px; }
    .kpis { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
    .btn-row button { padding:10px 8px; font-size:15px; }
    .wrap { padding-left:12px; padding-right:12px; }
  }

/* Settings grid: keep Resource and Availability side-by-side on mobile */
.settings-grid{display:grid; grid-template-columns:minmax(0,1fr) minmax(0,1fr); gap:12px; align-items:end}
.field{display:flex; flex-direction:column; gap:6px; min-width:0}
.field label{font-size:14px; color:var(--muted)}
.field input{width:100%}
</style>
</head>
<body>
  <div class="wrap">
    <header><h1>CycleTimer<br>ラップでサイクルタイム予測</h1></header>

    <div class="grid">
      <section class="card">
        <div class="row"><div class="big time" id="display">0'00"00</div></div>

        <!-- Target行＆チェック行：基本は一列で収める -->
        <div class="row nowrap" style="margin-top:10px">
          <label class="row nowrap" style="gap:8px">
            <span>Target（目標回数）</span>
            <input id="target" type="number" inputmode="numeric" min="0" step="1" value="100">
          </label>
          <div class="grow"></div>
          <label class="checkbox-line">
            <input type="checkbox" id="trimOutliers">
            <span class="muted">外れ値を自動除外（IQR方式）</span>
          </label>
        </div>

        
        
        <!-- 台数/人数 & 可動率 -->
        <div class="settings-grid" style="margin-top:10px">
          <div class="field">
            <label for="resource">台数/人数</label>
            <input id="resource" type="number" inputmode="numeric" min="1" step="1" value="1">
          </div>
          <div class="field">
            <label for="availability">可動率（%）</label>
            <input id="availability" type="number" inputmode="numeric" min="1" max="100" step="1" value="100">
          </div>
        </div>

        <div class="muted" style="margin-top:6px; font-size:12px">
          内部計算：Target ÷ 台数/人数 ／ 合計予測時間を ÷（可動率/100）
        </div>

<!-- KPI：1段目 -->
        <div class="kpis">
          <div class="kpi"><div class="label">現在回数</div><div class="val" id="count">0</div></div>
          <div class="kpi"><div class="label">平均CT</div><div class="val time" id="avg">–</div></div>
        </div>
        <!-- KPI：2段目（合計ETAは常に行フル幅） -->
        <div class="kpis">
          <div class="kpi" style="grid-column:1 / -1">
            <div class="label">目標回数までの到達予測時間（合計）</div>
            <div class="val time" id="etaTotal">–</div>
          </div>
        </div>
        <!-- KPI：3段目 -->
        <div class="kpis">
          <div class="kpi"><div class="label">最短CT</div><div class="val time" id="min">–</div></div>
          <div class="kpi"><div class="label">最長CT</div><div class="val time" id="max">–</div></div>
        </div>

        <!-- 操作ボタン -->
        <div class="btn-row">
          <button id="startStop" class="primary">Start</button>
          <button id="resetBtn" class="warn">Reset</button>
          <button id="undoBtn" class="ghost" disabled>Undo</button>
          <button id="lapBtn" disabled>Lap</button>
        </div>
      </section>

      <section class="card">
        <h3 style="margin:0">ラップ一覧</h3>
        <div class="scroll-print" style="overflow:auto; max-height:55vh; margin-top:8px">
          <table id="lapsTbl">
            <thead><tr><th>#</th><th>Lap</th><th>Cumulative</th><th></th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </section>
    </div>
  </div>

<script>
(() => {
  const state={running:false,startEpoch:0,accMs:0,lastLapEpoch:0,laps:[],target:100,resource:1,availability:100,trimOutliers:false};
  const $=s=>document.querySelector(s);
  const display=$('#display'),startStop=$('#startStop'),lapBtn=$('#lapBtn'),
        undoBtn=$('#undoBtn'),resetBtn=$('#resetBtn'),targetInp=$('#target'),resourceInp=$('#resource'),availabilityInp=$('#availability'),
        trimChk=$('#trimOutliers'),countEl=$('#count'),avgEl=$('#avg'),
        minEl=$('#min'),maxEl=$('#max'),etaTotalEl=$('#etaTotal'),tblBody=$('#lapsTbl tbody');

  // 行削除（任意のラップを削除）
  tblBody.addEventListener('click', (e)=>{
    const btn = e.target.closest && e.target.closest('button.del');
    if(!btn) return;
    const i = parseInt(btn.dataset.i, 10);
    if(Number.isInteger(i) && i>=0 && i<state.laps.length){
      state.laps.splice(i,1);
      render();
    }
  });

  const pad=(n,w=2)=>String(n).padStart(w,'0');
  const fmtHMSms=ms=>{ if(!isFinite(ms)||ms<0)ms=0;
    const csT=Math.floor(ms/10), cs=csT%100, sT=Math.floor(csT/100), s=sT%60, mT=Math.floor(sT/60), m=mT%60, h=Math.floor(mT/60);
    return (h>0?`${h}:`:'') + (h>0?pad(m):m) + `'` + pad(s) + `"` + pad(cs);
  };
  const mean=a=>a.length?a.reduce((x,y)=>x+y,0)/a.length:NaN;
  const now=()=>Date.now();

  const setIfNotFocused = (inp, val) => {
    if(!inp) return;
    if(document.activeElement === inp) return;
    inp.value = val;
  };

  const parseIntSafe = (v) => {
    const n = parseInt(v, 10);
    return Number.isFinite(n) ? n : null;
  };

  // IQR境界（lo/hi）を返す。データが少ないときは null。
  const iqrBounds = (arr) => {
    if (!arr || arr.length < 4) return null;
    const s = arr.slice().sort((a,b)=>a-b);
    const q = (p) => {
      const pos = (s.length - 1) * p;
      const b = Math.floor(pos), r = pos - b;
      return r ? s[b] + (s[b+1]-s[b]) * r : s[b];
    };
    const q1 = q(0.25), q3 = q(0.75), iqr = q3 - q1;
    return { lo: q1 - 1.5*iqr, hi: q3 + 1.5*iqr };
  };

  const render=()=>{
    const live=state.accMs+(state.running?now()-state.startEpoch:0);
    display.textContent=fmtHMSms(live);

    // IQR境界と、平均計算に使う配列
    const bounds = state.trimOutliers ? iqrBounds(state.laps) : null;
    const lapsForAvg = bounds ? state.laps.filter(v => v >= bounds.lo && v <= bounds.hi) : state.laps;

    // テーブル（外れ値は半透明で表示）
    tblBody.innerHTML=''; let cum=0;
    state.laps.forEach((lap,i)=>{
      cum+=lap;
      const excluded = !!(bounds && (lap < bounds.lo || lap > bounds.hi));
      const tr=document.createElement('tr');
      tr.innerHTML=`<td>#${i+1}</td>
                    <td class="${excluded?'excluded':''}">${fmtHMSms(lap)}</td>
                    <td>${fmtHMSms(cum)}</td>
                    <td><button class="del" data-i="${i}" aria-label="delete">×</button></td>`;
      tblBody.appendChild(tr);
    });

    // KPI
    const min=Math.min(...(state.laps.length?state.laps:[NaN]));
    const max=Math.max(...(state.laps.length?state.laps:[NaN]));
    const avg=mean(lapsForAvg);

    countEl.textContent=state.laps.length;
    avgEl.textContent=isFinite(avg)?fmtHMSms(avg):'–';
    minEl.textContent=isFinite(min)?fmtHMSms(min):'–';   // 最短/最長は生データ基準のまま
    maxEl.textContent=isFinite(max)?fmtHMSms(max):'–';
    const perTarget = state.resource>0 ? (state.target/state.resource) : state.target;
    const avail = (state.availability>0 ? state.availability : 100) / 100;
    const etaTotal = isFinite(avg) ? (avg * perTarget / avail) : NaN;
    etaTotalEl.textContent=isFinite(etaTotal)?fmtHMSms(etaTotal):'–';

    // ボタンと入力
    startStop.textContent=state.running?'Stop':'Start';
    lapBtn.disabled=!state.running; undoBtn.disabled=!state.laps.length;
    setIfNotFocused(targetInp, state.target);
    setIfNotFocused(resourceInp, state.resource);
    setIfNotFocused(availabilityInp, state.availability);
    trimChk.checked=state.trimOutliers;
  };

  const start=()=>{ if(state.running)return; state.running=true; state.startEpoch=now(); state.lastLapEpoch=state.startEpoch; render(); };
  const stop =()=>{ if(!state.running)return; state.accMs+=now()-state.startEpoch; state.running=false; render(); };
  const toggle=()=>state.running?stop():start();
  const lap  =()=>{ if(!state.running)return; const t=now(),ms=t-state.lastLapEpoch; state.lastLapEpoch=t; state.laps.push(ms); render(); };
  const undo =()=>{ if(!state.laps.length)return; state.laps.pop(); render(); };
  const reset=()=>{ stop(); state.accMs=0; state.lastLapEpoch=0; state.laps=[]; render(); };

  startStop.addEventListener('click',toggle);
  lapBtn.addEventListener('click',lap);
  undoBtn.addEventListener('click',undo);
  resetBtn.addEventListener('click',reset);
  // Target: 空欄入力中は強制上書きしない（Backspaceで消せない問題の対策）
  targetInp.addEventListener('input', (e)=>{
    const n = parseIntSafe(e.target.value);
    if(n === null) return;
    state.target = Math.max(0, n);
    render();
  });
  targetInp.addEventListener('blur', (e)=>{
    const n = parseIntSafe(e.target.value);
    if(n === null) { setIfNotFocused(targetInp, state.target); return; }
    state.target = Math.max(0, n);
    render();
  });
  // Resource（台数/人数）: 空欄入力中は強制上書きしない
  resourceInp.addEventListener('input', (e)=>{
    const n = parseIntSafe(e.target.value);
    if(n === null) return;
    state.resource = Math.max(1, n);
    render();
  });
  resourceInp.addEventListener('blur', (e)=>{
    const n = parseIntSafe(e.target.value);
    state.resource = Math.max(1, n ?? state.resource ?? 1);
    setIfNotFocused(resourceInp, state.resource);
    render();
  });

  // 可動率（%）
  availabilityInp.addEventListener('input', (e)=>{
    const n = parseIntSafe(e.target.value);
    if(n === null) return;
    state.availability = Math.min(100, Math.max(1, n));
    render();
  });
  availabilityInp.addEventListener('blur', (e)=>{
    const n = parseIntSafe(e.target.value);
    state.availability = Math.min(100, Math.max(1, n ?? state.availability ?? 100));
    setIfNotFocused(availabilityInp, state.availability);
    render();
  });

  trimChk.addEventListener('change',e=>{ state.trimOutliers=!!e.target.checked; render(); });

  setInterval(()=>{ if(state.running) render(); }, 50);
  render();
})();
</script>
</body>
</html>